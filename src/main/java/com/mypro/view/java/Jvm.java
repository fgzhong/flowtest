package com.mypro.view.java;

/**
 * @author fgzhong
 * @description: jvm内存结构
 * @since 2019/7/2
 */
public class Jvm {

    /*
      1、JVM内存划分
        // 线程共享
        1、堆：
          1、存储对象的实例；
          2、堆分成两块区新生代（young——一个Eden区和两个Suvivor区）和年老代（old）
          3、内存溢出：
        2、方法区：理论上来说是堆的逻辑组成部分
           永久代：-XX:PermSize：方法区初始大小；-XX:MaxPermSize：方法区最大大小
           元空间：-XX:MetaspaceSize  初始空间大小  XX:MaxMetaspaceSize  最大大小
                  -XX:MinMetaspaceFreeRatio 在GC之后，最小的Metaspace剩余空间容量的百分比，减少为分配空间所导致的垃圾收集
                  -XX:MaxMetaspaceFreeRatio 在GC之后，最大的Metaspace剩余空间容量的百分比，减少为释放空间所导致的垃圾收集
          1、加载的类信息，常量池，静态变量
          2、永久代、元空间
            1、不同：
               1、存储位置不同
                  1、永久代物理是是堆的一部分，和新生代，老年代地址是连续的
                  2、元空间属于本地内存
               2、存储内容不同
                  1、元空间存储类的元信息，静态变量和常量池等并入堆中
                  2、相当于永久代的数据被分到了堆和元空间中
          3、为什么要替换永久代
            1、大小是在启动时固定好的
            2、字符串常量池存储在永久代容易造成内存溢出
            3、永久代大小界定不易
            4、永久代会为 GC 带来不必要的复杂度，并且回收效率偏低
            5、
          4、常量池
            1、Class文件常量池
            2、运行时常量池
            3、字符串常量池：全局、唯一
          3、OutOfMemoneyError：加载的Class类过多，导致永久代内存不足
        // 线程私有
        3、虚拟机栈
          1、生命周期与线程一样。创建线程的时候就会创建一个java虚拟机栈
          2、每个方法都会创建一个栈帧，栈帧存放在java虚拟机栈中，通过压栈出栈的方式进行方法调用
          3、栈帧又分为一下几个区域：局部变量表、操作数栈、动态连接、方法出口等
          4、创建栈过多——内存溢出；栈深度过多——StackOverFlowError
        4、本地方法栈：使用到本地方法服务
        5、程序计数器：记录当前线程执行程序的位置
          1、多线程实现原理：通过线程轮流切换并分配处理器执行时间的方式实现的
          2、Java方法 —— 正在执行的虚拟机字节码指令的地址；Native方法 —— 计数器值则为空（Undefined）
      2、除程序计数器外，其他都会发生内存溢出
      3、
      4、内存溢出与内存泄漏、栈内存溢出StackOverFlowError
    */
}
